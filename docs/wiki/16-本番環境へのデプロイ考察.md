# 16. 本番環境へのデプロイ考察

このチュートリアルで作成した `weather-server` は、主にローカル環境でStdioトランスポートを介してMCPクライアントと連携することを想定しています。
しかし、MCPサーバーの概念はローカル実行に限定されるものではなく、リモートサーバーとしてデプロイし、HTTP(S) SSEなどのトランスポート経由で複数のクライアントから利用することも可能です。

このセクションでは、もし作成したMCPサーバーを本番環境（あるいはより永続的な環境）へデプロイする場合に考慮すべき点について、一般的な考察を述べます。

## 1. デプロイ先の選択肢

Node.jsアプリケーションをデプロイできる環境は多岐にわたります。

*   **PaaS (Platform as a Service)**:
    *   Heroku, Vercel, Netlify (主にフロントエンド向けだがNode.jsバックエンドも可), Google App Engine, AWS Elastic Beanstalk など。
    *   **メリット**: インフラ管理の手間が少なく、デプロイが比較的容易。スケーリングやロギングなどの機能が組み込まれていることが多い。
    *   **デメリット**: プラットフォームごとの制約がある場合がある。コストが利用量に応じて変動。
*   **コンテナ技術 (Docker + オーケストレーション)**:
    *   DockerでMCPサーバーをコンテナ化し、Kubernetes, Docker Swarm, Amazon ECS, Google Kubernetes Engine (GKE) などで管理・実行する。
    *   **メリット**: 環境のポータビリティが高い。スケーラビリティと可用性を細かく制御できる。
    *   **デメリット**: 学習コストが高い。インフラ構築・管理の知識が必要。
*   **IaaS (Infrastructure as a Service) / VPS (Virtual Private Server)**:
    *   Amazon EC2, Google Compute Engine, Microsoft Azure VMs, DigitalOcean Droplets, Linode など。
    *   **メリット**: サーバー環境を自由にカスタマイズできる。
    *   **デメリット**: OSのセットアップからセキュリティ対策、監視まですべて自前で行う必要がある。
*   **サーバーレス (Function as a Service)**:
    *   AWS Lambda, Google Cloud Functions, Azure Functions など。
    *   **メリット**: イベント駆動でコードを実行。スケーラビリティが高い。アイドリング時のコストが低い。
    *   **デメリット**: 長時間実行やステートフルな処理には向かない場合がある。MCPサーバーの常時待機モデルとは相性が悪い可能性がある（HTTPトリガーで都度起動する形なら可能か）。Stdio以外のトランスポート（HTTP SSEなど）が必須。

**Stdioベースのローカルサーバーの場合**:
今回の `weather-server` のようにStdioで動作するサーバーは、基本的にはクライアントと同じマシンか、クライアントから直接プロセスを起動できる環境で実行されます。これを「デプロイ」と呼ぶかは状況によりますが、永続的に動作させるためには後述するプロセスマネージャーの利用が考えられます。

## 2. 環境変数の管理

本番環境では、APIキーなどの機密情報を安全に管理する必要があります。

*   **デプロイ環境が提供する環境変数設定機能**: 多くのPaaSやコンテナオーケストレーションツールは、環境変数を安全に設定・注入する仕組みを提供しています。これを利用するのが第一選択です。
*   **シークレット管理サービス**: AWS Secrets Manager, Google Cloud Secret Manager, HashiCorp Vault など。より高度な機密情報管理が可能です。
*   `.env` ファイルは本番環境での利用は推奨されません（ビルドプロセスに含めてしまうリスクなどがあるため）。

## 3. プロセスの永続化と監視 (特にIaaS/VPSの場合)

サーバープロセスが予期せず終了した場合に自動で再起動したり、リソース使用状況を監視したりするためには、プロセスマネージャーの利用が推奨されます。

*   **PM2**: Node.jsアプリケーションで広く使われているプロセスマネージャー。クラスタリング、ログ管理、監視などの機能が豊富。
    ```bash
    # PM2のインストール (グローバル)
    npm install pm2 -g
    # MCPサーバーの起動
    pm2 start build/index.js --name weather-mcp-server --env OPENWEATHER_API_KEY=YOUR_KEY
    # 起動状況の確認
    pm2 list
    # ログの表示
    pm2 logs weather-mcp-server
    ```
*   **systemd (Linux)**: Linuxシステム標準のinitシステム。サービスとしてMCPサーバーを登録し、自動起動や再起動を設定可能。
*   **Dockerの再起動ポリシー**: Dockerコンテナとして実行する場合、コンテナの再起動ポリシーを設定できます。

## 4. ロギング

本番環境では、サーバーの動作状況やエラーを記録するための適切なロギングが不可欠です。

*   `console.log`, `console.error` は基本ですが、より構造化されたログを出力するライブラリ（Winston, Pinoなど）の利用を検討します。
*   ログの出力先: 標準出力/標準エラー出力だけでなく、ファイルや外部のログ集約サービス（Datadog, Splunk, ELK Stackなど）への転送も考慮します。
*   PaaSやコンテナ環境では、プラットフォームが提供するログ収集・閲覧機能を利用できることが多いです。

## 5. トランスポートの変更 (リモートデプロイの場合)

Stdioトランスポートはローカル実行専用です。もしMCPサーバーをリモートのサーバーにデプロイし、ネットワーク経由でアクセスさせる場合は、HTTP SSE (Server-Sent Events) などのネットワーク対応トランスポートに切り替える必要があります。
MCP SDK は `HttpServerTransport` のようなクラスを提供している（または将来的に提供する）可能性があります。その場合、`src/index.ts` のトランスポート設定部分を変更し、HTTPサーバーとしてリクエストを待ち受けるようにします。
また、ファイアウォール設定やHTTPS化も必須となります。

## 6. スケーラビリティと可用性 (大規模運用の場合)

もしMCPサーバーが多くのクライアントから頻繁にアクセスされるようになる場合は、スケーラビリティ（負荷に応じて処理能力を増減できるか）と可用性（障害時にもサービスを継続できるか）を考慮する必要があります。
これには、ロードバランサーの導入、複数インスタンスでのサーバー実行（クラスタリング）、データベースの最適化などが関わってきます。これは高度なトピックであり、通常は小規模なMCPサーバーではすぐには必要ありません。

---

このチュートリアルで作成するサーバーはローカル実行が主目的ですが、上記のような点を考慮することで、より本格的な運用にも対応できるMCPサーバーを設計・開発するための知識の足がかりとなります。